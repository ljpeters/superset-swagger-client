/*
 * Superset
 * Superset
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package at.mic.superset.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import at.mic.superset.swagger.client.model.ChartDataFilter;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * ChartDataExtras
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-11-06T17:36:10.263+01:00[Europe/Vienna]")
public class ChartDataExtras {
  @SerializedName("druid_time_origin")
  private String druidTimeOrigin = null;

  @SerializedName("having")
  private String having = null;

  @SerializedName("having_druid")
  private List<ChartDataFilter> havingDruid = null;

  /**
   * End time for relative time deltas. Default: &#x60;config[\&quot;DEFAULT_RELATIVE_START_TIME\&quot;]&#x60;
   */
  @JsonAdapter(RelativeEndEnum.Adapter.class)
  public enum RelativeEndEnum {
    TODAY("today"),
    NOW("now");

    private String value;

    RelativeEndEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static RelativeEndEnum fromValue(String text) {
      for (RelativeEndEnum b : RelativeEndEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<RelativeEndEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RelativeEndEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RelativeEndEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return RelativeEndEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("relative_end")
  private RelativeEndEnum relativeEnd = null;

  /**
   * Start time for relative time deltas. Default: &#x60;config[\&quot;DEFAULT_RELATIVE_START_TIME\&quot;]&#x60;
   */
  @JsonAdapter(RelativeStartEnum.Adapter.class)
  public enum RelativeStartEnum {
    TODAY("today"),
    NOW("now");

    private String value;

    RelativeStartEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static RelativeStartEnum fromValue(String text) {
      for (RelativeStartEnum b : RelativeStartEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<RelativeStartEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final RelativeStartEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public RelativeStartEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return RelativeStartEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("relative_start")
  private RelativeStartEnum relativeStart = null;

  /**
   * To what level of granularity should the temporal column be aggregated. Supports [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) durations.
   */
  @JsonAdapter(TimeGrainSqlaEnum.Adapter.class)
  public enum TimeGrainSqlaEnum {
    PT1S("PT1S"),
    PT1M("PT1M"),
    PT5M("PT5M"),
    PT10M("PT10M"),
    PT15M("PT15M"),
    PT0_5H("PT0.5H"),
    PT1H("PT1H"),
    P1D("P1D"),
    P1W("P1W"),
    P1M("P1M"),
    P0_25Y("P0.25Y"),
    P1Y("P1Y"),
    _1969_12_28T00_00_00Z_P1W("1969-12-28T00:00:00Z/P1W"),
    _1969_12_29T00_00_00Z_P1W("1969-12-29T00:00:00Z/P1W"),
    P1W_1970_01_03T00_00_00Z("P1W/1970-01-03T00:00:00Z"),
    P1W_1970_01_04T00_00_00Z("P1W/1970-01-04T00:00:00Z");

    private String value;

    TimeGrainSqlaEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TimeGrainSqlaEnum fromValue(String text) {
      for (TimeGrainSqlaEnum b : TimeGrainSqlaEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TimeGrainSqlaEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TimeGrainSqlaEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TimeGrainSqlaEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TimeGrainSqlaEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("time_grain_sqla")
  private TimeGrainSqlaEnum timeGrainSqla = null;

  /**
   * A list with two values, stating if start/end should be inclusive/exclusive.
   */
  @JsonAdapter(TimeRangeEndpointsEnum.Adapter.class)
  public enum TimeRangeEndpointsEnum {
    UNKNOWN("unknown"),
    INCLUSIVE("inclusive"),
    EXCLUSIVE("exclusive");

    private String value;

    TimeRangeEndpointsEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TimeRangeEndpointsEnum fromValue(String text) {
      for (TimeRangeEndpointsEnum b : TimeRangeEndpointsEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TimeRangeEndpointsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TimeRangeEndpointsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TimeRangeEndpointsEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TimeRangeEndpointsEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("time_range_endpoints")
  private List<TimeRangeEndpointsEnum> timeRangeEndpoints = null;

  @SerializedName("where")
  private String where = null;

  public ChartDataExtras druidTimeOrigin(String druidTimeOrigin) {
    this.druidTimeOrigin = druidTimeOrigin;
    return this;
  }

   /**
   * Starting point for time grain counting on legacy Druid datasources. Used to change e.g. Monday/Sunday first-day-of-week.
   * @return druidTimeOrigin
  **/
  @Schema(description = "Starting point for time grain counting on legacy Druid datasources. Used to change e.g. Monday/Sunday first-day-of-week.")
  public String getDruidTimeOrigin() {
    return druidTimeOrigin;
  }

  public void setDruidTimeOrigin(String druidTimeOrigin) {
    this.druidTimeOrigin = druidTimeOrigin;
  }

  public ChartDataExtras having(String having) {
    this.having = having;
    return this;
  }

   /**
   * HAVING clause to be added to aggregate queries using AND operator.
   * @return having
  **/
  @Schema(description = "HAVING clause to be added to aggregate queries using AND operator.")
  public String getHaving() {
    return having;
  }

  public void setHaving(String having) {
    this.having = having;
  }

  public ChartDataExtras havingDruid(List<ChartDataFilter> havingDruid) {
    this.havingDruid = havingDruid;
    return this;
  }

  public ChartDataExtras addHavingDruidItem(ChartDataFilter havingDruidItem) {
    if (this.havingDruid == null) {
      this.havingDruid = new ArrayList<ChartDataFilter>();
    }
    this.havingDruid.add(havingDruidItem);
    return this;
  }

   /**
   * HAVING filters to be added to legacy Druid datasource queries.
   * @return havingDruid
  **/
  @Schema(description = "HAVING filters to be added to legacy Druid datasource queries.")
  public List<ChartDataFilter> getHavingDruid() {
    return havingDruid;
  }

  public void setHavingDruid(List<ChartDataFilter> havingDruid) {
    this.havingDruid = havingDruid;
  }

  public ChartDataExtras relativeEnd(RelativeEndEnum relativeEnd) {
    this.relativeEnd = relativeEnd;
    return this;
  }

   /**
   * End time for relative time deltas. Default: &#x60;config[\&quot;DEFAULT_RELATIVE_START_TIME\&quot;]&#x60;
   * @return relativeEnd
  **/
  @Schema(description = "End time for relative time deltas. Default: `config[\"DEFAULT_RELATIVE_START_TIME\"]`")
  public RelativeEndEnum getRelativeEnd() {
    return relativeEnd;
  }

  public void setRelativeEnd(RelativeEndEnum relativeEnd) {
    this.relativeEnd = relativeEnd;
  }

  public ChartDataExtras relativeStart(RelativeStartEnum relativeStart) {
    this.relativeStart = relativeStart;
    return this;
  }

   /**
   * Start time for relative time deltas. Default: &#x60;config[\&quot;DEFAULT_RELATIVE_START_TIME\&quot;]&#x60;
   * @return relativeStart
  **/
  @Schema(description = "Start time for relative time deltas. Default: `config[\"DEFAULT_RELATIVE_START_TIME\"]`")
  public RelativeStartEnum getRelativeStart() {
    return relativeStart;
  }

  public void setRelativeStart(RelativeStartEnum relativeStart) {
    this.relativeStart = relativeStart;
  }

  public ChartDataExtras timeGrainSqla(TimeGrainSqlaEnum timeGrainSqla) {
    this.timeGrainSqla = timeGrainSqla;
    return this;
  }

   /**
   * To what level of granularity should the temporal column be aggregated. Supports [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) durations.
   * @return timeGrainSqla
  **/
  @Schema(example = "P1D", description = "To what level of granularity should the temporal column be aggregated. Supports [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Durations) durations.")
  public TimeGrainSqlaEnum getTimeGrainSqla() {
    return timeGrainSqla;
  }

  public void setTimeGrainSqla(TimeGrainSqlaEnum timeGrainSqla) {
    this.timeGrainSqla = timeGrainSqla;
  }

  public ChartDataExtras timeRangeEndpoints(List<TimeRangeEndpointsEnum> timeRangeEndpoints) {
    this.timeRangeEndpoints = timeRangeEndpoints;
    return this;
  }

  public ChartDataExtras addTimeRangeEndpointsItem(TimeRangeEndpointsEnum timeRangeEndpointsItem) {
    if (this.timeRangeEndpoints == null) {
      this.timeRangeEndpoints = new ArrayList<TimeRangeEndpointsEnum>();
    }
    this.timeRangeEndpoints.add(timeRangeEndpointsItem);
    return this;
  }

   /**
   * Get timeRangeEndpoints
   * @return timeRangeEndpoints
  **/
  @Schema(description = "")
  public List<TimeRangeEndpointsEnum> getTimeRangeEndpoints() {
    return timeRangeEndpoints;
  }

  public void setTimeRangeEndpoints(List<TimeRangeEndpointsEnum> timeRangeEndpoints) {
    this.timeRangeEndpoints = timeRangeEndpoints;
  }

  public ChartDataExtras where(String where) {
    this.where = where;
    return this;
  }

   /**
   * WHERE clause to be added to queries using AND operator.
   * @return where
  **/
  @Schema(description = "WHERE clause to be added to queries using AND operator.")
  public String getWhere() {
    return where;
  }

  public void setWhere(String where) {
    this.where = where;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ChartDataExtras chartDataExtras = (ChartDataExtras) o;
    return Objects.equals(this.druidTimeOrigin, chartDataExtras.druidTimeOrigin) &&
        Objects.equals(this.having, chartDataExtras.having) &&
        Objects.equals(this.havingDruid, chartDataExtras.havingDruid) &&
        Objects.equals(this.relativeEnd, chartDataExtras.relativeEnd) &&
        Objects.equals(this.relativeStart, chartDataExtras.relativeStart) &&
        Objects.equals(this.timeGrainSqla, chartDataExtras.timeGrainSqla) &&
        Objects.equals(this.timeRangeEndpoints, chartDataExtras.timeRangeEndpoints) &&
        Objects.equals(this.where, chartDataExtras.where);
  }

  @Override
  public int hashCode() {
    return Objects.hash(druidTimeOrigin, having, havingDruid, relativeEnd, relativeStart, timeGrainSqla, timeRangeEndpoints, where);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ChartDataExtras {\n");
    
    sb.append("    druidTimeOrigin: ").append(toIndentedString(druidTimeOrigin)).append("\n");
    sb.append("    having: ").append(toIndentedString(having)).append("\n");
    sb.append("    havingDruid: ").append(toIndentedString(havingDruid)).append("\n");
    sb.append("    relativeEnd: ").append(toIndentedString(relativeEnd)).append("\n");
    sb.append("    relativeStart: ").append(toIndentedString(relativeStart)).append("\n");
    sb.append("    timeGrainSqla: ").append(toIndentedString(timeGrainSqla)).append("\n");
    sb.append("    timeRangeEndpoints: ").append(toIndentedString(timeRangeEndpoints)).append("\n");
    sb.append("    where: ").append(toIndentedString(where)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
