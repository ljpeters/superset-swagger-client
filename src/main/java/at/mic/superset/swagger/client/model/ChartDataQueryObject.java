/*
 * Superset
 * Superset
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package at.mic.superset.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import at.mic.superset.swagger.client.model.ChartDataExtras;
import at.mic.superset.swagger.client.model.ChartDataFilter;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * ChartDataQueryObject
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2020-11-06T17:36:10.263+01:00[Europe/Vienna]")
public class ChartDataQueryObject {
  @SerializedName("columns")
  private List<String> columns = null;

  @SerializedName("extras")
  private ChartDataExtras extras = null;

  @SerializedName("filters")
  private List<ChartDataFilter> filters = null;

  @SerializedName("granularity")
  private String granularity = null;

  @SerializedName("granularity_sqla")
  private String granularitySqla = null;

  @SerializedName("groupby")
  private List<String> groupby = null;

  @SerializedName("having")
  private String having = null;

  @SerializedName("having_filters")
  private List<ChartDataFilter> havingFilters = null;

  @SerializedName("is_timeseries")
  private Boolean isTimeseries = null;

  @SerializedName("metrics")
  private List<Object> metrics = null;

  @SerializedName("order_desc")
  private Boolean orderDesc = null;

  @SerializedName("orderby")
  private List<List<Object>> orderby = null;

  @SerializedName("post_processing")
  private List<AllOfChartDataQueryObjectPostProcessingItems> postProcessing = null;

  @SerializedName("row_limit")
  private Integer rowLimit = null;

  @SerializedName("row_offset")
  private Integer rowOffset = null;

  @SerializedName("time_range")
  private String timeRange = null;

  @SerializedName("time_shift")
  private String timeShift = null;

  @SerializedName("timeseries_limit")
  private Integer timeseriesLimit = null;

  @SerializedName("timeseries_limit_metric")
  private Object timeseriesLimitMetric = null;

  @SerializedName("where")
  private String where = null;

  public ChartDataQueryObject columns(List<String> columns) {
    this.columns = columns;
    return this;
  }

  public ChartDataQueryObject addColumnsItem(String columnsItem) {
    if (this.columns == null) {
      this.columns = new ArrayList<String>();
    }
    this.columns.add(columnsItem);
    return this;
  }

   /**
   * Get columns
   * @return columns
  **/
  @Schema(description = "")
  public List<String> getColumns() {
    return columns;
  }

  public void setColumns(List<String> columns) {
    this.columns = columns;
  }

  public ChartDataQueryObject extras(ChartDataExtras extras) {
    this.extras = extras;
    return this;
  }

   /**
   * Get extras
   * @return extras
  **/
  @Schema(description = "")
  public ChartDataExtras getExtras() {
    return extras;
  }

  public void setExtras(ChartDataExtras extras) {
    this.extras = extras;
  }

  public ChartDataQueryObject filters(List<ChartDataFilter> filters) {
    this.filters = filters;
    return this;
  }

  public ChartDataQueryObject addFiltersItem(ChartDataFilter filtersItem) {
    if (this.filters == null) {
      this.filters = new ArrayList<ChartDataFilter>();
    }
    this.filters.add(filtersItem);
    return this;
  }

   /**
   * Get filters
   * @return filters
  **/
  @Schema(description = "")
  public List<ChartDataFilter> getFilters() {
    return filters;
  }

  public void setFilters(List<ChartDataFilter> filters) {
    this.filters = filters;
  }

  public ChartDataQueryObject granularity(String granularity) {
    this.granularity = granularity;
    return this;
  }

   /**
   * Name of temporal column used for time filtering. For legacy Druid datasources this defines the time grain.
   * @return granularity
  **/
  @Schema(description = "Name of temporal column used for time filtering. For legacy Druid datasources this defines the time grain.")
  public String getGranularity() {
    return granularity;
  }

  public void setGranularity(String granularity) {
    this.granularity = granularity;
  }

  public ChartDataQueryObject granularitySqla(String granularitySqla) {
    this.granularitySqla = granularitySqla;
    return this;
  }

   /**
   * Name of temporal column used for time filtering for SQL datasources. This field is deprecated, use &#x60;granularity&#x60; instead.
   * @return granularitySqla
  **/
  @Schema(description = "Name of temporal column used for time filtering for SQL datasources. This field is deprecated, use `granularity` instead.")
  public String getGranularitySqla() {
    return granularitySqla;
  }

  public void setGranularitySqla(String granularitySqla) {
    this.granularitySqla = granularitySqla;
  }

  public ChartDataQueryObject groupby(List<String> groupby) {
    this.groupby = groupby;
    return this;
  }

  public ChartDataQueryObject addGroupbyItem(String groupbyItem) {
    if (this.groupby == null) {
      this.groupby = new ArrayList<String>();
    }
    this.groupby.add(groupbyItem);
    return this;
  }

   /**
   * Get groupby
   * @return groupby
  **/
  @Schema(description = "")
  public List<String> getGroupby() {
    return groupby;
  }

  public void setGroupby(List<String> groupby) {
    this.groupby = groupby;
  }

  public ChartDataQueryObject having(String having) {
    this.having = having;
    return this;
  }

   /**
   * HAVING clause to be added to aggregate queries using AND operator. This field is deprecated and should be passed to &#x60;extras&#x60;.
   * @return having
  **/
  @Schema(description = "HAVING clause to be added to aggregate queries using AND operator. This field is deprecated and should be passed to `extras`.")
  public String getHaving() {
    return having;
  }

  public void setHaving(String having) {
    this.having = having;
  }

  public ChartDataQueryObject havingFilters(List<ChartDataFilter> havingFilters) {
    this.havingFilters = havingFilters;
    return this;
  }

  public ChartDataQueryObject addHavingFiltersItem(ChartDataFilter havingFiltersItem) {
    if (this.havingFilters == null) {
      this.havingFilters = new ArrayList<ChartDataFilter>();
    }
    this.havingFilters.add(havingFiltersItem);
    return this;
  }

   /**
   * HAVING filters to be added to legacy Druid datasource queries. This field is deprecated and should be passed to &#x60;extras&#x60; as &#x60;having_druid&#x60;.
   * @return havingFilters
  **/
  @Schema(description = "HAVING filters to be added to legacy Druid datasource queries. This field is deprecated and should be passed to `extras` as `having_druid`.")
  public List<ChartDataFilter> getHavingFilters() {
    return havingFilters;
  }

  public void setHavingFilters(List<ChartDataFilter> havingFilters) {
    this.havingFilters = havingFilters;
  }

  public ChartDataQueryObject isTimeseries(Boolean isTimeseries) {
    this.isTimeseries = isTimeseries;
    return this;
  }

   /**
   * Is the &#x60;query_object&#x60; a timeseries.
   * @return isTimeseries
  **/
  @Schema(description = "Is the `query_object` a timeseries.")
  public Boolean isIsTimeseries() {
    return isTimeseries;
  }

  public void setIsTimeseries(Boolean isTimeseries) {
    this.isTimeseries = isTimeseries;
  }

  public ChartDataQueryObject metrics(List<Object> metrics) {
    this.metrics = metrics;
    return this;
  }

  public ChartDataQueryObject addMetricsItem(Object metricsItem) {
    if (this.metrics == null) {
      this.metrics = new ArrayList<Object>();
    }
    this.metrics.add(metricsItem);
    return this;
  }

   /**
   * Aggregate expressions. Metrics can be passed as both references to datasource metrics (strings), or ad-hoc metricswhich are defined only within the query object. See &#x60;ChartDataAdhocMetricSchema&#x60; for the structure of ad-hoc metrics.
   * @return metrics
  **/
  @Schema(description = "Aggregate expressions. Metrics can be passed as both references to datasource metrics (strings), or ad-hoc metricswhich are defined only within the query object. See `ChartDataAdhocMetricSchema` for the structure of ad-hoc metrics.")
  public List<Object> getMetrics() {
    return metrics;
  }

  public void setMetrics(List<Object> metrics) {
    this.metrics = metrics;
  }

  public ChartDataQueryObject orderDesc(Boolean orderDesc) {
    this.orderDesc = orderDesc;
    return this;
  }

   /**
   * Reverse order. Default: &#x60;false&#x60;
   * @return orderDesc
  **/
  @Schema(description = "Reverse order. Default: `false`")
  public Boolean isOrderDesc() {
    return orderDesc;
  }

  public void setOrderDesc(Boolean orderDesc) {
    this.orderDesc = orderDesc;
  }

  public ChartDataQueryObject orderby(List<List<Object>> orderby) {
    this.orderby = orderby;
    return this;
  }

  public ChartDataQueryObject addOrderbyItem(List<Object> orderbyItem) {
    if (this.orderby == null) {
      this.orderby = new ArrayList<List<Object>>();
    }
    this.orderby.add(orderbyItem);
    return this;
  }

   /**
   * Expects a list of lists where the first element is the column name which to sort by, and the second element is a boolean 
   * @return orderby
  **/
  @Schema(example = "[[\"my_col_1\",false],[\"my_col_2\",true]]", description = "Expects a list of lists where the first element is the column name which to sort by, and the second element is a boolean ")
  public List<List<Object>> getOrderby() {
    return orderby;
  }

  public void setOrderby(List<List<Object>> orderby) {
    this.orderby = orderby;
  }

  public ChartDataQueryObject postProcessing(List<AllOfChartDataQueryObjectPostProcessingItems> postProcessing) {
    this.postProcessing = postProcessing;
    return this;
  }

  public ChartDataQueryObject addPostProcessingItem(AllOfChartDataQueryObjectPostProcessingItems postProcessingItem) {
    if (this.postProcessing == null) {
      this.postProcessing = new ArrayList<AllOfChartDataQueryObjectPostProcessingItems>();
    }
    this.postProcessing.add(postProcessingItem);
    return this;
  }

   /**
   * Post processing operations to be applied to the result set. Operations are applied to the result set in sequential order.
   * @return postProcessing
  **/
  @Schema(description = "Post processing operations to be applied to the result set. Operations are applied to the result set in sequential order.")
  public List<AllOfChartDataQueryObjectPostProcessingItems> getPostProcessing() {
    return postProcessing;
  }

  public void setPostProcessing(List<AllOfChartDataQueryObjectPostProcessingItems> postProcessing) {
    this.postProcessing = postProcessing;
  }

  public ChartDataQueryObject rowLimit(Integer rowLimit) {
    this.rowLimit = rowLimit;
    return this;
  }

   /**
   * Maximum row count. Default: &#x60;config[\&quot;ROW_LIMIT\&quot;]&#x60;
   * minimum: 1
   * @return rowLimit
  **/
  @Schema(description = "Maximum row count. Default: `config[\"ROW_LIMIT\"]`")
  public Integer getRowLimit() {
    return rowLimit;
  }

  public void setRowLimit(Integer rowLimit) {
    this.rowLimit = rowLimit;
  }

  public ChartDataQueryObject rowOffset(Integer rowOffset) {
    this.rowOffset = rowOffset;
    return this;
  }

   /**
   * Number of rows to skip. Default: &#x60;0&#x60;
   * minimum: 0
   * @return rowOffset
  **/
  @Schema(description = "Number of rows to skip. Default: `0`")
  public Integer getRowOffset() {
    return rowOffset;
  }

  public void setRowOffset(Integer rowOffset) {
    this.rowOffset = rowOffset;
  }

  public ChartDataQueryObject timeRange(String timeRange) {
    this.timeRange = timeRange;
    return this;
  }

   /**
   * A time rage, either expressed as a colon separated string &#x60;since : until&#x60; or human readable freeform. Valid formats for &#x60;since&#x60; and &#x60;until&#x60; are:  - ISO 8601 - X days/years/hours/day/year/weeks - X days/years/hours/day/year/weeks ago - X days/years/hours/day/year/weeks from now  Additionally, the following freeform can be used:  - Last day - Last week - Last month - Last quarter - Last year - No filter - Last X seconds/minutes/hours/days/weeks/months/years - Next X seconds/minutes/hours/days/weeks/months/years 
   * @return timeRange
  **/
  @Schema(example = "Last week", description = "A time rage, either expressed as a colon separated string `since : until` or human readable freeform. Valid formats for `since` and `until` are:  - ISO 8601 - X days/years/hours/day/year/weeks - X days/years/hours/day/year/weeks ago - X days/years/hours/day/year/weeks from now  Additionally, the following freeform can be used:  - Last day - Last week - Last month - Last quarter - Last year - No filter - Last X seconds/minutes/hours/days/weeks/months/years - Next X seconds/minutes/hours/days/weeks/months/years ")
  public String getTimeRange() {
    return timeRange;
  }

  public void setTimeRange(String timeRange) {
    this.timeRange = timeRange;
  }

  public ChartDataQueryObject timeShift(String timeShift) {
    this.timeShift = timeShift;
    return this;
  }

   /**
   * A human-readable date/time string. Please refer to [parsdatetime](https://github.com/bear/parsedatetime) documentation for details on valid values.
   * @return timeShift
  **/
  @Schema(description = "A human-readable date/time string. Please refer to [parsdatetime](https://github.com/bear/parsedatetime) documentation for details on valid values.")
  public String getTimeShift() {
    return timeShift;
  }

  public void setTimeShift(String timeShift) {
    this.timeShift = timeShift;
  }

  public ChartDataQueryObject timeseriesLimit(Integer timeseriesLimit) {
    this.timeseriesLimit = timeseriesLimit;
    return this;
  }

   /**
   * Maximum row count for timeseries queries. Default: &#x60;0&#x60;
   * @return timeseriesLimit
  **/
  @Schema(description = "Maximum row count for timeseries queries. Default: `0`")
  public Integer getTimeseriesLimit() {
    return timeseriesLimit;
  }

  public void setTimeseriesLimit(Integer timeseriesLimit) {
    this.timeseriesLimit = timeseriesLimit;
  }

  public ChartDataQueryObject timeseriesLimitMetric(Object timeseriesLimitMetric) {
    this.timeseriesLimitMetric = timeseriesLimitMetric;
    return this;
  }

   /**
   * Metric used to limit timeseries queries by.
   * @return timeseriesLimitMetric
  **/
  @Schema(description = "Metric used to limit timeseries queries by.")
  public Object getTimeseriesLimitMetric() {
    return timeseriesLimitMetric;
  }

  public void setTimeseriesLimitMetric(Object timeseriesLimitMetric) {
    this.timeseriesLimitMetric = timeseriesLimitMetric;
  }

  public ChartDataQueryObject where(String where) {
    this.where = where;
    return this;
  }

   /**
   * WHERE clause to be added to queries using AND operator.This field is deprecated and should be passed to &#x60;extras&#x60;.
   * @return where
  **/
  @Schema(description = "WHERE clause to be added to queries using AND operator.This field is deprecated and should be passed to `extras`.")
  public String getWhere() {
    return where;
  }

  public void setWhere(String where) {
    this.where = where;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ChartDataQueryObject chartDataQueryObject = (ChartDataQueryObject) o;
    return Objects.equals(this.columns, chartDataQueryObject.columns) &&
        Objects.equals(this.extras, chartDataQueryObject.extras) &&
        Objects.equals(this.filters, chartDataQueryObject.filters) &&
        Objects.equals(this.granularity, chartDataQueryObject.granularity) &&
        Objects.equals(this.granularitySqla, chartDataQueryObject.granularitySqla) &&
        Objects.equals(this.groupby, chartDataQueryObject.groupby) &&
        Objects.equals(this.having, chartDataQueryObject.having) &&
        Objects.equals(this.havingFilters, chartDataQueryObject.havingFilters) &&
        Objects.equals(this.isTimeseries, chartDataQueryObject.isTimeseries) &&
        Objects.equals(this.metrics, chartDataQueryObject.metrics) &&
        Objects.equals(this.orderDesc, chartDataQueryObject.orderDesc) &&
        Objects.equals(this.orderby, chartDataQueryObject.orderby) &&
        Objects.equals(this.postProcessing, chartDataQueryObject.postProcessing) &&
        Objects.equals(this.rowLimit, chartDataQueryObject.rowLimit) &&
        Objects.equals(this.rowOffset, chartDataQueryObject.rowOffset) &&
        Objects.equals(this.timeRange, chartDataQueryObject.timeRange) &&
        Objects.equals(this.timeShift, chartDataQueryObject.timeShift) &&
        Objects.equals(this.timeseriesLimit, chartDataQueryObject.timeseriesLimit) &&
        Objects.equals(this.timeseriesLimitMetric, chartDataQueryObject.timeseriesLimitMetric) &&
        Objects.equals(this.where, chartDataQueryObject.where);
  }

  @Override
  public int hashCode() {
    return Objects.hash(columns, extras, filters, granularity, granularitySqla, groupby, having, havingFilters, isTimeseries, metrics, orderDesc, orderby, postProcessing, rowLimit, rowOffset, timeRange, timeShift, timeseriesLimit, timeseriesLimitMetric, where);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ChartDataQueryObject {\n");
    
    sb.append("    columns: ").append(toIndentedString(columns)).append("\n");
    sb.append("    extras: ").append(toIndentedString(extras)).append("\n");
    sb.append("    filters: ").append(toIndentedString(filters)).append("\n");
    sb.append("    granularity: ").append(toIndentedString(granularity)).append("\n");
    sb.append("    granularitySqla: ").append(toIndentedString(granularitySqla)).append("\n");
    sb.append("    groupby: ").append(toIndentedString(groupby)).append("\n");
    sb.append("    having: ").append(toIndentedString(having)).append("\n");
    sb.append("    havingFilters: ").append(toIndentedString(havingFilters)).append("\n");
    sb.append("    isTimeseries: ").append(toIndentedString(isTimeseries)).append("\n");
    sb.append("    metrics: ").append(toIndentedString(metrics)).append("\n");
    sb.append("    orderDesc: ").append(toIndentedString(orderDesc)).append("\n");
    sb.append("    orderby: ").append(toIndentedString(orderby)).append("\n");
    sb.append("    postProcessing: ").append(toIndentedString(postProcessing)).append("\n");
    sb.append("    rowLimit: ").append(toIndentedString(rowLimit)).append("\n");
    sb.append("    rowOffset: ").append(toIndentedString(rowOffset)).append("\n");
    sb.append("    timeRange: ").append(toIndentedString(timeRange)).append("\n");
    sb.append("    timeShift: ").append(toIndentedString(timeShift)).append("\n");
    sb.append("    timeseriesLimit: ").append(toIndentedString(timeseriesLimit)).append("\n");
    sb.append("    timeseriesLimitMetric: ").append(toIndentedString(timeseriesLimitMetric)).append("\n");
    sb.append("    where: ").append(toIndentedString(where)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
